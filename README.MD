Devnology E-Commerce - Desafio Full-Stack J√∫nior
!(https://img.shields.io/badge/react-%2320232A.svg?style=for-the-badge&logo=react&logoColor=%2361DAFB)

!(https://img.shields.io/badge/nestjs-%23E0234E.svg?style=for-the-badge&logo=nestjs&logoColor=white)

!(https://img.shields.io/badge/docker-%230db7ed.svg?style=for-the-badge&logo=docker&logoColor=white)

Este reposit√≥rio cont√©m a solu√ß√£o completa para o desafio t√©cnico de Desenvolvedor(a) Full-Stack J√∫nior. O projeto consiste em uma plataforma de e-commerce que integra produtos de dois fornecedores distintos (um brasileiro e um europeu) e oferece uma experi√™ncia de compra coesa atrav√©s de uma aplica√ß√£o web (React) e um aplicativo mobile (Flutter), ambos consumindo um backend centralizado (NestJS).

üåü Funcionalidades
Backend Unificado: Uma API RESTful em NestJS que atua como um API Gateway, buscando, unificando e servindo os dados dos produtos de forma centralizada.

Persist√™ncia de Dados: Registro de todos os pedidos e dados de clientes em um banco de dados PostgreSQL, gerenciado via Docker.

Aplica√ß√£o Web (React): Interface reativa e moderna constru√≠da com Vite, permitindo:

Listagem de produtos com busca por nome e filtro por origem.

Carrinho de compras com gerenciamento de estado local.

Formul√°rio de checkout para finaliza√ß√£o da compra.

Aplicativo Mobile (Flutter): Experi√™ncia nativa para Android (e iOS) com as mesmas funcionalidades da aplica√ß√£o web, compartilhando o mesmo backend.

üì∏ Demonstra√ß√£o
Aplica√ß√£o Web (React)
Lista de Produtos e Filtros

Carrinho de Compras (Modal)

!(https://i.imgur.com/g8e1m8F.png)

!(https://i.imgur.com/gK9pZkH.png)


Exportar para as Planilhas
Aplicativo Mobile (Flutter)
Lista de Produtos

Tela do Carrinho

!(https://i.imgur.com/D4sYvso.png)

!(https://i.imgur.com/e8p2T6I.png)


Exportar para as Planilhas
üõ†Ô∏è Tecnologias Utilizadas
Categoria

Tecnologia

Backend

Node.js, NestJS, TypeScript, TypeORM

Frontend Web

React, Vite, TypeScript, Tailwind CSS

App Mobile

Flutter, Dart

Banco de Dados

PostgreSQL

Gerenciamento de Estado

React Context API, Flutter Provider

Containeriza√ß√£o

Docker, Docker Compose

Testes de API

Insomnia / Postman


Exportar para as Planilhas
üöÄ Como Rodar o Projeto
Este projeto √© um monorepo. Todos os comandos de instala√ß√£o e execu√ß√£o devem ser feitos a partir do diret√≥rio raiz, salvo indica√ß√£o contr√°ria.

Pr√©-requisitos
Antes de come√ßar, garanta que voc√™ tem as seguintes ferramentas instaladas:

Node.js (v18 ou superior)
-(https://flutter.dev/docs/get-started/install)
-(https://www.docker.com/products/docker-desktop/) e Docker Compose

Instala√ß√£o
Clone o reposit√≥rio:

Bash

git clone https://github.com/RoberthFurtadoDev/Teste-IN8-Junior.git
cd Teste-IN8-Junior
Instale todas as depend√™ncias (backend e frontend) com um √∫nico comando a partir da raiz:

Bash

npm install
Execu√ß√£o
Para rodar a aplica√ß√£o completa, voc√™ precisar√° de 3 terminais abertos.

1. Iniciar o Banco de Dados (PostgreSQL)

No primeiro terminal, a partir da pasta raiz, inicie o cont√™iner do Docker:

Bash

docker-compose up -d
2. Iniciar o Backend (NestJS)

No segundo terminal, navegue at√© a pasta do backend e inicie o servidor:

Bash

cd apps/backend
npm run start:dev
O servidor estar√° rodando em http://localhost:3000.

3. Iniciar a Aplica√ß√£o Web (React)

No terceiro terminal, navegue at√© a pasta do frontend e inicie o servidor de desenvolvimento:

Bash

cd apps/frontend
npm run dev
A aplica√ß√£o web estar√° dispon√≠vel em http://localhost:5173 (ou outra porta indicada pelo Vite).

4. Iniciar o Aplicativo Mobile (Flutter)

Garanta que um emulador Android esteja rodando ou um dispositivo f√≠sico esteja conectado.

No terceiro terminal (ou em um novo), navegue at√© a pasta do app mobile e execute:

Bash

cd apps/mobile
flutter run
Importante: O c√≥digo do Flutter j√° est√° configurado para usar o IP 10.0.2.2 para se comunicar com o backend rodando no seu computador a partir do emulador Android.

üß† Decis√µes T√©cnicas Tomadas
Esta se√ß√£o detalha as principais escolhas arquiteturais feitas durante o desenvolvimento, visando n√£o apenas cumprir os requisitos, mas construir uma solu√ß√£o robusta, escal√°vel e alinhada com as melhores pr√°ticas do mercado.  ¬† 

Arquitetura de Monorepo:

Decis√£o: O projeto foi estruturado como um monorepo, contendo as pastas apps/backend, apps/frontend e apps/mobile em um √∫nico reposit√≥rio Git.

Justificativa: Esta abordagem centraliza a gest√£o de depend√™ncias, simplifica a configura√ß√£o do ambiente de desenvolvimento e facilita o compartilhamento de c√≥digo e tipos (como as interfaces TypeScript entre o backend e o frontend).  ¬† 

Backend como API Gateway:

Decis√£o: Em vez de fazer os clientes (React e Flutter) chamarem as duas APIs de fornecedores, o backend em NestJS foi implementado seguindo o padr√£o API Gateway.  ¬† 

Justificativa: Esta √© a decis√£o arquitetural mais impactante do projeto. Ela abstrai a complexidade dos m√∫ltiplos fornecedores para os clientes, que agora consomem um √∫nico e coeso endpoint (/products). Isso simplifica drasticamente o c√≥digo do frontend e do mobile, centraliza a l√≥gica de neg√≥cios, permite a implementa√ß√£o de cache no servidor e torna o sistema muito mais f√°cil de manter e escalar (adicionar um novo fornecedor se torna uma tarefa exclusiva do backend).  ¬† 

Gerenciamento de Estado:

React (Context API + useReducer): Para o carrinho de compras na web, foi escolhida a Context API nativa do React, combinada com o hook useReducer.  ¬† 

Justificativa: Esta abordagem oferece um gerenciamento de estado robusto e previs√≠vel, similar ao Redux, mas sem a necessidade de bibliotecas externas e com menos boilerplate. Para a escala deste projeto, √© a solu√ß√£o mais pragm√°tica e eficiente, demonstrando profici√™ncia com as ferramentas nativas do React.  ¬† 

Flutter (Provider): Para o app mobile, foi utilizado o pacote provider.

Justificativa: Provider √© a abordagem recomendada oficialmente pelo time do Flutter para gerenciamento de estado. √â simples, poderoso e perfeitamente adequado para compartilhar o estado do carrinho por toda a √°rvore de widgets da aplica√ß√£o.

Persist√™ncia de Dados e Schema do Banco:

Decis√£o: O banco de dados PostgreSQL foi escolhido por sua robustez e conformidade com o padr√£o SQL. O schema foi desenhado para garantir a integridade hist√≥rica dos pedidos.

Justificativa: Na tabela order_items, foram armazenados n√£o apenas o product_id, mas tamb√©m o product_name e o price no momento da compra. Isso garante que, mesmo que os dados dos produtos mudem nas APIs externas, os registros de pedidos permane√ßam historicamente precisos, o que √© vital para relat√≥rios financeiros e para o hist√≥rico do cliente.  ¬† 

Desenvolvimento Multiplataforma (Web e Mobile):

Decis√£o: O desafio foi cumprido integralmente, com a entrega de ambas as plataformas obrigat√≥rias (React e Flutter).

Justificativa: A constru√ß√£o de ambas as interfaces consumindo o mesmo backend demonstra uma compreens√£o completa do desenvolvimento full-stack e da import√¢ncia de uma API bem projetada como a √∫nica fonte da verdade para m√∫ltiplos clientes.  ¬† 

Este projeto foi desenvolvido com o objetivo de demonstrar n√£o apenas a capacidade de codificar, mas de pensar arquiteturalmente, tomar decis√µes t√©cnicas justificadas e entregar uma solu√ß√£o completa e de alta qualidade.