## PROJETO E-COMMERCE FULL-STACK - DEV[N]OLOGY
Solu√ß√£o completa de e-commerce desenvolvida para o desafio t√©cnico de Desenvolvedor(a) Full-Stack. O sistema integra produtos de dois fornecedores distintos via API e oferece uma experi√™ncia de compra atrav√©s de uma aplica√ß√£o web (React) e um aplicativo mobile (Flutter), ambos consumindo um backend centralizado (NestJS).

## ‚ú® FUNCIONALIDADES IMPLEMENTADAS
O projeto foi conclu√≠do com sucesso, entregando todos os requisitos obrigat√≥rios e opcionais.

[x] Backend em Node.js com NestJS

[x] Endpoint unificado para produtos

[x] Registro de compras no banco de dados via API

[x] Interface Web com React

[x] Listagem de produtos dos dois fornecedores

[x] Busca e filtro de produtos

[x] Carrinho de compras (adicionar/remover)

[x] Finaliza√ß√£o da compra com formul√°rio

[x] Aplicativo Mobile com Flutter

[x] Listagem de produtos consumindo o mesmo backend

[x] Carrinho de compras funcional

[x] Finaliza√ß√£o da compra e registro do pedido

## üíª PR√â-REQUISITOS
Antes de come√ßar, verifique se voc√™ atendeu aos seguintes requisitos:

Voc√™ instalou a vers√£o mais recente de:

Node.js (v18 ou superior)

(https://flutter.dev/docs/get-started/install)

(https://www.docker.com/products/docker-desktop/)

Voc√™ tem uma m√°quina Windows, Linux ou Mac.

Voc√™ tem um editor de c√≥digo como o VS Code.

## üöÄ INSTALANDO O PROJETO
Para instalar o projeto, siga estas etapas:

Bash

# Clone o reposit√≥rio
git clone https://github.com/RoberthFurtadoDev/Teste-IN8-Junior.git

# Navegue at√© a pasta do projeto
cd Teste-IN8-Junior

# Instale todas as depend√™ncias (backend e frontend)
npm install
## üî• EXECUTANDO A APLICA√á√ÉO
Para rodar a aplica√ß√£o completa, voc√™ precisar√° de 3 terminais abertos na raiz do projeto.

Bash

# A partir da pasta raiz, inicie o cont√™iner do PostgreSQL
docker-compose up -d
Bash

# Navegue at√© a pasta do backend
cd apps/backend

# Inicie o servidor em modo de desenvolvimento
npm run start:dev
O servidor estar√° rodando em http://localhost:3000.

Bash

# Navegue at√© a pasta do frontend
cd apps/frontend

# Inicie o servidor de desenvolvimento
npm run dev
A aplica√ß√£o web estar√° dispon√≠vel em http://localhost:5173.

Bash

# Garanta que um emulador Android esteja rodando
# Navegue at√© a pasta do app mobile
cd apps/mobile

# Execute o aplicativo
flutter run
O c√≥digo j√° est√° configurado para se comunicar com o backend a partir do navegador/emulador.

## üß† DECIS√ïES T√âCNICAS E ARQUITETURAIS
Esta se√ß√£o detalha as principais escolhas feitas durante o desenvolvimento, visando n√£o apenas cumprir os requisitos, mas construir uma solu√ß√£o robusta, escal√°vel e alinhada com as melhores pr√°ticas do mercado.  ¬† 

1. ARQUITETURA DE MONOREPO
Decis√£o: O projeto foi estruturado como um monorepo, contendo as pastas apps/backend, apps/frontend e apps/mobile em um √∫nico reposit√≥rio Git.

Justificativa: Esta abordagem centraliza a gest√£o de depend√™ncias, simplifica a configura√ß√£o do ambiente de desenvolvimento e facilita o compartilhamento de c√≥digo e tipos (como as interfaces TypeScript entre o backend e o frontend).  ¬† 

2. BACKEND COMO API GATEWAY
Decis√£o: Em vez de fazer os clientes (React e Flutter) chamarem as duas APIs de fornecedores, o backend em NestJS foi implementado seguindo o padr√£o API Gateway.  ¬† 

Justificativa: Esta √© a decis√£o arquitetural mais impactante do projeto. Ela abstrai a complexidade dos m√∫ltiplos fornecedores para os clientes, que agora consomem um √∫nico e coeso endpoint (/products). Isso simplifica drasticamente o c√≥digo do frontend e do mobile, centraliza a l√≥gica de neg√≥cios, permite a implementa√ß√£o de cache no servidor e torna o sistema muito mais f√°cil de manter e escalar.  ¬† 

3. GERENCIAMENTO DE ESTADO
React (Context API): Para o carrinho de compras na web, foi escolhida a Context API nativa do React.  ¬† 

Justificativa: Esta abordagem oferece um gerenciamento de estado robusto e previs√≠vel, ideal para a escala deste projeto, sem a complexidade e o boilerplate de bibliotecas externas como o Redux. Demonstra profici√™ncia com as ferramentas nativas do React para resolver problemas de estado compartilhado.  ¬† 

Flutter (Provider): Para o app mobile, foi utilizado o pacote provider.

Justificativa: Provider √© a abordagem recomendada oficialmente pelo time do Flutter para gerenciamento de estado. √â simples, poderoso e perfeitamente adequado para compartilhar o estado do carrinho por toda a √°rvore de widgets da aplica√ß√£o.

4. PERSIST√äNCIA DE DADOS E SCHEMA DO BANCO
Decis√£o: O banco de dados PostgreSQL foi escolhido por sua robustez e conformidade com o padr√£o SQL. O schema foi desenhado para garantir a integridade hist√≥rica dos pedidos.

Justificativa: Na tabela que armazena os itens de um pedido, foram gravados n√£o apenas o product_id, mas tamb√©m o product_name e o price no momento da compra. Isso garante que, mesmo que os dados dos produtos mudem nas APIs externas, os registros de pedidos permane√ßam historicamente precisos, o que √© vital para relat√≥rios financeiros e para o hist√≥rico do cliente.  ¬† 

5. DESENVOLVIMENTO MULTIPLATAFORMA
Decis√£o: O desafio foi cumprido integralmente, com a entrega de ambas as plataformas obrigat√≥rias (React e Flutter).

Justificativa: A constru√ß√£o de ambas as interfaces consumindo o mesmo backend demonstra uma compreens√£o completa do desenvolvimento full-stack e da import√¢ncia de uma API bem projetada como a √∫nica fonte da verdade para m√∫ltiplos clientes.  ¬† 

üíª Roberth Furtado ¬© 2025 | Todos os direitos reservados.
